<% content_for :title do %>Binary Search<% end %>
<h1>Binary Search</h1>
<p>Binary search relies on a divide and conquer strategy to find a value within an already-sorted collection. The algorithm is deceptively simple. Pretend I was thinking of a number between 1 and 100. Every guess you take, I'll say higher or lower. The most efficient way to discover my number is to first guess 50. Higher. 75. Lower. 62. Higher 68. Yes!</p>

<h2>Implementation</h2>
<pre id="code1">function findIndex(values, target) {
  <span class="line">return binarySearch(values, target, 0, values.length - 1);</span>
};

function binarySearch(values, target, start, end) {
  <span class="line">if (start > end) { return -1; }</span> //does not exist 

  <span class="line">var middle = Math.floor((start + end) / 2);</span>
  <span class="line">var value = values[middle];</span>

  <span class="line">if (value > target)</span> { return <span class="line">binarySearch(values, target, start, middle-1);</span> }
  <span class="line">if (value &lt; target)</span> { return <span class="line">binarySearch(values, target, middle+1, end);</span> }
  <span class="line">return middle; //found!</span>
}
<span class="line">findIndex([1, 4, 6, 7, 12, 13, 15, 18, 19, 20, 22, 24], 20);</span>
<span class="line">//finished</span>
</pre>

<h2>Example</h2>
<p>Click <em>step</em> to find <code>20</code> within our sorted array</p>
<div id="example1">
  <div class="nodeList">
    <div>1</div>
    <div>4</div>
    <div>6</div>
    <div>7</div>
    <div>12</div>
    <div>13</div>
    <div>15</div>
    <div>18</div>
    <div>19</div>
    <div>20</div>
    <div>22</div>
    <div>24</div>
  </div>
  <div class="step">step</div>
</div>

<h2>Characteristics</h2>
<p>Every iteration eliminates half of the remaining possibilities. This makes binary searches very efficient - even for large collections. Our implementation relies on recursion, though it is equally as common to see an iterative approach.</p>

<p>Binary search requires a sorted collection. This means the collection must either be sorted before searching, or inserts/updates must be smart. Also, binary searching can only be applied to a collection that allows random access (indexing).</p>

<h2>In The Real World</h2>
<p>Binary searching is frequently used thanks to its performance characteristics over large collections. The only time binary searching doesn't make sense is when the collection is being frequently updated (relative to searches), since re-sorting will be required.</p>

<p>Hash tables can often provide better (though somewhat unreliable) performance. Typically, it's relatively clear when data belongs in a hash table (for frequent lookups) versus when a search is needed.</p>
  
<div id="nav">
  <a href="/structures/hashtables" id="prev">&laquo; hash tables</a>
  <a href="/sort/bubblesort" id="next">bubble sort &raquo;</a>
</div>

<%= erb :disqus, :locals => {:identifier => '/algo/binarysearch'}%>

<script type="text/javascript">
$(document).ready(function()
{
  var $code1 = $('#code1').code({});
  $('#example1').example({code: $code1, instructions: instructions.binarySearch});
});
</script>